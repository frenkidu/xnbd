<!doctype refentry PUBLIC "-//OASIS//DTD DocBook V4.5//EN" [

<!-- Process this file with docbook-to-man to generate an nroff manual
     page: `docbook-to-man manpage.sgml > manpage.1'.  You may view
     the manual page with: `docbook-to-man manpage.sgml | nroff -man |
     less'.  A typical entry in a Makefile or Makefile.am is:

manpage.1: manpage.sgml
	docbook-to-man $< > $@
  -->

  <!-- Fill in your name for FIRSTNAME and SURNAME. -->
  <!ENTITY dhfirstname "<firstname>Arno</firstname>">
  <!ENTITY dhsurname   "<surname>Toell</surname>">
  <!-- Please adjust the date whenever revising the manpage. -->
  <!ENTITY dhdate      "<date>$Date$</date>">
  <!-- SECTION should be 1-8, maybe w/ subsection other parameters are
       allowed: see man(7), man(1). -->
  <!ENTITY dhsection   "<manvolnum>8</manvolnum>">
  <!ENTITY dhemail     "<email>debian@toell.net</email>">
  <!ENTITY dhusername  "Arno Toell">
  <!ENTITY dhucpackage "<refentrytitle>XNBD-SERVER</refentrytitle>">
  <!ENTITY dhpackage   "xnbd-server">

  <!ENTITY debian      "<productname>Debian GNU/Linux</productname>">
  <!ENTITY gnu         "<acronym>GNU</acronym>">
]>

<refentry>
  <refentryinfo>
    <address>
      &dhemail;
    </address>
    <author>
      &dhfirstname;
      &dhsurname;
    </author>
    <copyright>
      <year>2011</year>
      <holder>&dhusername;</holder>
    </copyright>
    &dhdate;
  </refentryinfo>
  <refmeta>
    &dhucpackage;

    &dhsection;
  </refmeta>
  <refnamediv>
    <refname>&dhpackage;</refname>

    <refpurpose>serve a file as a block device to other computers via the NBD protocol</refpurpose>
  </refnamediv>
  <refsynopsisdiv>
    <cmdsynopsis>
      <command>&dhpackage; --target</command>
      <arg><replaceable>options</replaceable></arg>
      <arg choice=plain><option>
		      <replaceable>DISK_IMAGE</replaceable>
      </option></arg>
    </cmdsynopsis>

    <cmdsynopsis>
      <command>&dhpackage; --cow-target</command>
      <arg><replaceable>options</replaceable></arg>
      <arg choice=plain><option>
		      <replaceable>BASE_DISK_IMAGE</replaceable>
      </option></arg>
    </cmdsynopsis>

    <cmdsynopsis>
      <command>&dhpackage; --proxy</command>
      <arg><replaceable>options</replaceable></arg>
      <arg choice=plain><option>
		      <replaceable>REMOTE_HOST</replaceable>
		      <replaceable>REMOTE_PORT</replaceable>
		      <replaceable>CACHE_IMAGE</replaceable>
		      <replaceable>CACHE_BITMAP_IMAGE</replaceable>
		      <replaceable>CONTROL_SOCKET_PATH</replaceable>
      </option></arg>
    </cmdsynopsis>

    <cmdsynopsis>
      <command>&dhpackage; --help</command>
    </cmdsynopsis>

    <cmdsynopsis>
      <command>&dhpackage; --version</command>
    </cmdsynopsis>
  </refsynopsisdiv>
  <refsect1>
    <title>DESCRIPTION</title>

    <para>
	    <command>&dhpackage;</command> is a server program of the 
	    Network Block Device (NBD) protocol.
	    It exports an image file to the clients of the NBD protocol over network.
	    A client node can access to the exported file through a block-level I/O interface;
	    it is possible to create swap areas on it or create file systems on it.
	    <!-- 
	    With xNBD, a client can use a file,
	    exported over the network from a server, as a block device.
	    It can then be used for whatever purpose a normal block device (hard disk,
	    CD-ROM, ...) can be used for.

	    The NBD protocol is used for diskless clients that need swap space and 
	    but also create a file system on it and use it as though it
	    were a local file system.
	    -->
    </para>

    <para>
	    The xNBD (i.e., extended NBD) programs offer several advantages over the original NBD implementation. In
	    addition to the original features, xNBD is intended to achieve better performance. It supports
	    (distributed) copy-on-write, (basic) snapshot support, live storage
	    migration for virtual machines, and IPv6 networking.
    </para>

    <para>
	    <command>&dhpackage;</command> can operate in three modes (i.e., the
	    target mode, the copy-on-write target mode, and the proxy mode).
    </para>
    <para> <command>&dhpackage; --target </command>
	    exports <replaceable>DISK_IMAGE</replaceable> to clients.
    </para>
    <para> <command>&dhpackage; --cow-target </command>
	    exports
	    <replaceable>BASE_DISK_IMAGE</replaceable> to clients. Write-operations are
	    not committed to the exported disk image, but to a separate file.
	    This separate file is removed when the server instance
	    is shutdown, and all changes are lost.
	    <!--
	    which means that serving this way will make xnbd-server slow down (especially on large block devices
	    with lots of writes). After disconnecting and reconnecting the client or the server,
	    -->
    </para>
    <para> 
	    <command>&dhpackage; --proxy </command>
	    provides the image server of the NBD protocol,
	    but it actually works as a proxy to a remote <command>&dhpackage;</command> specified with
	    <replaceable>REMOTE_HOST</replaceable> and
	    <replaceable>REMOTE_PORT</replaceable>. All I/O requests from
	    clients are intercepted, and redirected to the remote target server
	    if needed.  All updated blocks are cached at the proxy server, and
	    read blocks are also cached. No write operation does not happen at the remote
	    server. Cached blocks are saved in
	    <replaceable>CACHE_DISK_IMAGE</replaceable>.  The block numbers of
	    cached blocks are saved in
	    <replaceable>CACHE_BITMAP_IMAGE</replaceable>.  The proxy server is
	    controlled by <command>xnbd-bgctl</command>(1) through
	    <replaceable>CONTROL_SOCKET_PATH</replaceable>.  The proxy server
	    can be used for distributed copy-on-write NBD disks; one read-only
	    disk image is shared among multiple clients. It is also useful for
	    live storage migration of virtual machines.
    </para>
    <para>
	    <emphasis>WARNING:</emphasis> Multiple clients can concurrently access to a single server instance.
	    Yet <command>&dhpackage;</command> does not offer any locking or synchronization mechanism among concurent clients.
	    In most cases you WILL need a cluster file system on the exported image to avoid damage on your data.
    </para>
  </refsect1>
  <refsect1>
    <title>OPTIONS</title>

    <para>The following options are supported:</para>

    <variablelist>

      <varlistentry>
	<term><option>--daemonize</option>
	</term>
	<listitem>
		<para>Run <command>&dhpackage;</command> in the background</para>
	</listitem>
      </varlistentry>

      <varlistentry>
        <term><option>--inetd</option></term>
        <listitem>
		<para>
			Run <command>&dhpackage;</command> for an Internet super-server daemon (e.g., inetd). All network I/O is redirected to the stdin descriptor.
		</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><option>--logpath <replaceable>FILE</replaceable></option>
        </term>
        <listitem>
          <para>Log informational messages to the given <replaceable>FILE</replaceable>. </para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><option>--syslog</option>
        </term>
        <listitem>
          <para>Log informational messages to syslog. </para>
        </listitem>
      </varlistentry>

      <varlistentry>
	<term><option>--lport <replaceable>PORT</replaceable></option>
	</term>
	<listitem>
		<para>
			Listen incoming connections on the given <replaceable>PORT</replaceable>.
			<!--
			A valid port is any number between 1 and 65536. You may not use the same listeing
			port more than once per system. 
			-->
			If this argument is not given, <command>&dhpackage;</command> will listen on port 8520 by default.
		</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><option>--readonly</option></term>
	<listitem>
		<para>Export the image file as read only. If a client sends a write request, it will receive an error, but
			the connection will stay up.</para>
	</listitem>
      </varlistentry>

    </variablelist>
  </refsect1>

  <!-- TODO: POSITIONAL ARGUMENTS are explained above, but summarized here? -->
  <!-- 
  <refsect1>
    <title>POSITIONAL ARGUMENTS</title>

    <para>The following positional options are supported:</para>

    <variablelist>
      <varlistentry>
	<term><option>DISK_IMAGE</option></term>
	<listitem>
	  <para>The file that should be exported. This
	  can be an arbitrary file, including a disk image file and a real block device (i.e., a block device like <emphasis>/dev/sda1</emphasis>).</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><option>REMOTE_HOST</option></term>
	<listitem>
	  <para>When in the proxy mode, use the given <replaceable>REMOTE_HOST</replaceable> as the origin host. The resulting
          xnbd-server instance will forward requests transparently to this remote side.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><option>REMOTE_PORT</option></term>
	<listitem>
	  <para>The target origin port to connect in proxy mode</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><option>BITMAP_IMAGE</option></term>
	<listitem>
	  <para>The bitmap file uses for synchronization when connecting to a target
          origin host. A bitmap file records block numbers of updated and cached blocks.</para>
	</listitem>
      </varlistentry>
  </variablelist>
  </refsect1>
  -->
  <refsect1>
    <title>SIGNALS</title>
    <variablelist>
      <varlistentry>
        <term><option>SIGUSR</option></term>
        <listitem>
		<para>
			Take a snapshot of the image file. Currently, this feature works only in the targert mode.
		</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term><option>SIGHUP</option></term>
        <listitem>
		<para>
			Change the proxy mode to the target mode. Use <command>xnbd-bgctl --shutdown</command> instead of sending this signal. 
		</para>
        </listitem>
      </varlistentry>
    </variablelist>
  </refsect1>

  <refsect1>
    <title>SEE ALSO</title>

    <para>xnbd-client (1).</para>
    <para>xnbd-bgctl (1).</para>

  </refsect1>
  <refsect1>
    <title>AUTHOR</title>
    <para>The NBD kernel module and the NBD tools have been written by
    Pavel Macheck (pavel@ucw.cz) and is now maintained by Paul Clements.
    (Paul.Clements@steeleye.com).</para>

    <para>The xNBD userland progams have been written by
     Takahiro Hirofuchi (t.hirofuchi@aist.go.jp)</para>

    <para>This manual page was firstly written by &dhusername; (&dhemail;) for
    the &debian; system (but may be used by others). Large parts are
    verbatim copies of the original nbd-server and nbd-client manual
    pages written by Wouter Verhelst (wouter@debian.org). Permission is
    granted to copy, distribute and/or modify this document under the
    terms of the <acronym>GNU</acronym> General Public License,
    version 2, as published by the Free Software Foundation.</para>

  </refsect1>
</refentry>

